<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Brüche – Repräsentanten Generator</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
    h1 { font-size: 1.25rem; margin: 0 0 12px; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 16px; max-width: 1020px; }
    .controls {
      display: grid;
      grid-template-columns: repeat(12, minmax(0, 1fr));
      gap: 10px;
      align-items: end;
      margin-bottom: 10px;
    }
    .field { display: flex; flex-direction: column; gap: 6px; }
    label { font-size: 0.95rem; }
    input, select, button { font-size: 1rem; padding: 7px 10px; }
    input[type="number"] { width: 100%; }
    input[type="color"] { padding: 0; height: 38px; width: 100%; }
    .checks { display: flex; flex-wrap: wrap; gap: 14px; align-items: center; margin: 8px 0 12px; }
    .checks label { display: inline-flex; gap: 8px; align-items: center; }
    .actions { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    button { cursor: pointer; }
    canvas { border: 1px solid #222; border-radius: 10px; margin-top: 14px; background: #fff; max-width: 100%; }
    .small { font-size: 0.92rem; color: #555; }
    .warn { color: #8a2a00; }
    .hint { margin-top: 10px; color: #444; font-size: 0.95rem; }
    .span-2 { grid-column: span 2; }
    .span-3 { grid-column: span 3; }
    .span-4 { grid-column: span 4; }
    .span-5 { grid-column: span 5; }
    .span-6 { grid-column: span 6; }
    .span-12 { grid-column: span 12; }

    @media (max-width: 920px){
      .controls { grid-template-columns: repeat(6, minmax(0, 1fr)); }
      .span-2, .span-3, .span-4, .span-5, .span-6 { grid-column: span 3; }
    }
    @media (max-width: 520px){
      .controls { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .span-2, .span-3, .span-4, .span-5, .span-6 { grid-column: span 2; }
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Brüche – Repräsentanten Generator</h1>

    <div class="controls">
      <div class="field span-2">
        <label for="num">Zähler</label>
        <input id="num" type="number" value="4" min="0" step="1">
      </div>

      <div class="field span-2">
        <label for="den">Nenner</label>
        <input id="den" type="number" value="6" min="1" step="1">
      </div>

      <div class="field span-3">
        <label for="shape">Form</label>
        <select id="shape">
          <option value="square">Quadrat</option>
          <option value="rectangle">Rechteck</option>
          <option value="circle">Kreis</option>
        </select>
      </div>

      <div class="field span-3">
        <label for="mode">Darstellung</label>
        <select id="mode">
          <option value="stripes">Streifen</option>
          <option value="grid">Gitter (falls möglich)</option>
        </select>
      </div>

      <div class="field span-1">
        <label for="fillColor">Füllfarbe</label>
        <input id="fillColor" type="color" value="#2b6cb0">
      </div>

      <div class="field span-1">
        <label for="strokeColor">Randfarbe</label>
        <input id="strokeColor" type="color" value="#111111">
      </div>

      <div class="field span-2">
        <label for="size">Größe</label>
        <select id="size">
          <option value="140">klein</option>
          <option value="180" selected>mittel</option>
          <option value="240">groß</option>
        </select>
      </div>

      <div class="field span-12">
        <div class="checks">
          <label><input type="checkbox" id="showOutline" checked> Umrandung/Teilung anzeigen</label>
          <label><input type="checkbox" id="showLabel" checked> Bruch beschriften</label>
          <label><input type="checkbox" id="showUnitLabel"> Einheiten beschriften (1,2, …)</label>
        </div>

        <div class="actions">
          <button id="btnDraw">Generieren</button>
          <button id="btnJpg">Download JPG</button>
          <button id="btnSvg">Download SVG</button>
          <span class="small" id="status"></span>
        </div>
      </div>
    </div>

    <canvas id="cnv" width="980" height="420"></canvas>

    <div class="hint">
      Tipp: Für Arbeitsblätter ist <b>SVG</b> ideal (verlustfrei skalierbar). Für Präsentationen ist <b>JPG</b> praktisch.
      <br><span class="small">Hinweis: Sehr große Zähler/Nenner werden automatisch „darstellungsfreundlich“ begrenzt, damit alles flüssig bleibt.</span>
    </div>
  </div>

<script>
/** =========================
 *  Performance-Konfiguration
 *  ========================= */
const PERF = {
  MAX_DEN: 60,         // Nenner-Obergrenze (Darstellung)
  MAX_UNITS: 12,       // max. Einheiten bei unechten Brüchen
  FAST_MODE_DEN: 40,   // ab hier Kreis-Schnellmodus
  FAST_MODE_LINES: 12  // max. Linien im Kreis-Schnellmodus
};

const cnv = document.getElementById("cnv");
const ctx = cnv.getContext("2d");

function clampInt(x, min, max){
  const v = Math.floor(Number(x));
  if (Number.isNaN(v)) return min;
  return Math.min(max, Math.max(min, v));
}
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }
function simplify(num, den){
  const g = gcd(num, den);
  return { num: num/g, den: den/g, g };
}
function computeUnits(num, den){
  const whole = Math.floor(num / den);
  const rest = num % den;
  const units = whole + (rest > 0 ? 1 : 0);
  return { whole, rest, units };
}
function setStatus(msg, isWarn=false){
  const el = document.getElementById("status");
  el.textContent = msg;
  el.classList.toggle("warn", isWarn);
}
function clearCanvas(){
  ctx.clearRect(0,0,cnv.width,cnv.height);
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,cnv.width,cnv.height);
}
function drawLabel(text, x, y){
  ctx.save();
  ctx.fillStyle = "#111";
  ctx.font = "16px system-ui, Arial, sans-serif";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText(text, x, y);
  ctx.restore();
}
function drawUnitIndex(text, x, y){
  ctx.save();
  ctx.fillStyle = "#111";
  ctx.font = "14px system-ui, Arial, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, x, y);
  ctx.restore();
}

function getInputs(){
  const originalNum = clampInt(document.getElementById("num").value, 0, 10000);
  const originalDen = clampInt(document.getElementById("den").value, 1, 10000);
  const shape = document.getElementById("shape").value;
  const mode = document.getElementById("mode").value; // stripes | grid
  const fillColor = document.getElementById("fillColor").value;
  const strokeColor = document.getElementById("strokeColor").value;
  const showOutline = document.getElementById("showOutline").checked;
  const showLabel = document.getElementById("showLabel").checked;
  const showUnitLabel = document.getElementById("showUnitLabel").checked;
  const size = clampInt(document.getElementById("size").value, 80, 400);

  const simp = simplify(originalNum, originalDen);

  // Performance-Clipping: Nenner begrenzen, Bruchwert näherungsweise erhalten
  let num = originalNum;
  let den = originalDen;
  let denClipped = false;

  if (den > PERF.MAX_DEN){
    denClipped = true;
    const value = num / den;
    den = PERF.MAX_DEN;
    num = Math.round(value * den);
  }

  return {
    originalNum, originalDen, num, den, denClipped,
    shape, mode,
    fillColor, strokeColor,
    showOutline, showLabel, showUnitLabel,
    size, simp
  };
}

function computeLayout(shape, size){
  let unitW = size;
  let unitH = size;
  if (shape === "rectangle"){
    unitW = Math.round(size * 1.35);
    unitH = size;
  }
  return { unitW, unitH };
}

/** =========================
 *  Quadrat / Rechteck
 *  - stripes: den horizontale Streifen
 *  - grid: nur wenn den perfekte Quadratzahl (z.B. 9 -> 3x3)
 * ========================= */
function drawSquareOrRectCanvas({x,y,w,h, den, filledParts, fillColor, strokeColor, showOutline, mode}){
  // Fallback: wenn grid gewählt, aber nicht möglich -> stripes
  let usedMode = mode;
  const root = Math.sqrt(den);
  if (mode === "grid" && !Number.isInteger(root)){
    usedMode = "stripes";
  }

  // Pixel-alignment für scharfe Linien
  ctx.save();
  ctx.translate(0.5, 0.5);

  if (usedMode === "stripes"){
    const partH = h / den;

    // Füllung
    for (let i=0; i<den; i++){
      if (i < filledParts){
        ctx.fillStyle = fillColor;
        ctx.fillRect(x, y + i*partH, w, partH);
      }
    }

    // Teil-Linien
    if (showOutline){
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 2;
      for (let i=1; i<den; i++){
        const yy = y + i*partH;
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x + w, yy);
        ctx.stroke();
      }
    }

    // Außenrahmen
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 3;
    ctx.strokeRect(x, y, w, h);
  }

  if (usedMode === "grid"){
    const n = root; // integer
    const rows = n, cols = n;
    const cellW = w / cols;
    const cellH = h / rows;

    let counter = 0;
    for (let r=0; r<rows; r++){
      for (let c=0; c<cols; c++){
        if (counter < filledParts){
          ctx.fillStyle = fillColor;
          ctx.fillRect(x + c*cellW, y + r*cellH, cellW, cellH);
        }
        if (showOutline){
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = 1.5;
          ctx.strokeRect(x + c*cellW, y + r*cellH, cellW, cellH);
        }
        counter++;
      }
    }

    // Außenrahmen
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 3;
    ctx.strokeRect(x, y, w, h);
  }

  ctx.restore();
}

/** =========================
 *  Kreis
 *  - detailed: den Segmente
 *  - fast: 1 Füllsektor + wenige Linien
 * ========================= */
function drawCircleDetailed({cx, cy, r, den, filledParts, fillColor, strokeColor, showOutline}){
  for(let i=0; i<den; i++){
    const a0 = (2*Math.PI/den)*i - Math.PI/2;
    const a1 = (2*Math.PI/den)*(i+1) - Math.PI/2;

    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, a0, a1);
    ctx.closePath();

    if (i < filledParts){
      ctx.fillStyle = fillColor;
      ctx.fill();
    }
    if (showOutline){
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  // Außenkreis
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, 2*Math.PI);
  ctx.strokeStyle = strokeColor;
  ctx.lineWidth = showOutline ? 3 : 2;
  ctx.stroke();
}

function drawCircleFast({cx, cy, r, frac, fillColor, strokeColor, showOutline}){
  // Außenkreis
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, 2*Math.PI);
  ctx.strokeStyle = strokeColor;
  ctx.lineWidth = showOutline ? 3 : 2;
  ctx.stroke();

  // Füllsektor (1 Pfad)
  if (frac > 0){
    const a0 = -Math.PI/2;
    const a1 = a0 + 2*Math.PI*frac;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, a0, a1);
    ctx.closePath();
    ctx.fillStyle = fillColor;
    ctx.fill();
  }

  // wenige Radienlinien
  if (showOutline){
    const L = Math.max(2, Math.min(PERF.FAST_MODE_LINES, 60));
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 1.5;
    for (let i=0; i<L; i++){
      const ang = (2*Math.PI/L)*i - Math.PI/2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + r*Math.cos(ang), cy + r*Math.sin(ang));
      ctx.stroke();
    }
  }
}

/** =========================
 *  Zeichnen (Canvas)
 * ========================= */
function drawCanvas(){
  const s = getInputs();
  const { whole, rest, units } = computeUnits(s.num, s.den);

  const clippedUnits = Math.min(units, PERF.MAX_UNITS);
  const unitsClipped = units > PERF.MAX_UNITS;

  const margin = 20;
  const gap = 26;
  const top = 60;

  const { unitW, unitH } = computeLayout(s.shape, s.size);

  const maxPerRow = Math.max(1, Math.floor((cnv.width - 2*margin + gap) / (unitW + gap)));
  const rows = Math.ceil(clippedUnits / maxPerRow);
  const neededH = top + rows*(unitH + 50) + margin;
  const targetH = Math.max(420, neededH);

  if (Math.abs(cnv.height - targetH) > 2) cnv.height = targetH;
  clearCanvas();

  let warn = false;

  // Label oben
  if (s.showLabel){
    let label = `${s.originalNum}/${s.originalDen}`;
    if (s.simp.g > 1) label += ` (vereinfacht: ${s.simp.num}/${s.simp.den})`;
    if (s.denClipped){
      label += `  → Darstellung begrenzt (ca. ${s.num}/${s.den})`;
      warn = true;
    }
    drawLabel(label, margin, 18);
  }

  // Hinweis, falls grid nicht möglich
  const gridPossible = Number.isInteger(Math.sqrt(s.den));
  const gridWantedButNotPossible = (s.mode === "grid" && (s.shape === "square" || s.shape === "rectangle") && !gridPossible);

  // Kreis-Schnellmodus?
  const circleFastMode = (s.shape === "circle" && s.den > PERF.FAST_MODE_DEN);

  for (let u=0; u<clippedUnits; u++){
    const row = Math.floor(u / maxPerRow);
    const col = u % maxPerRow;
    const x = margin + col*(unitW + gap);
    const y = top + row*(unitH + 50);

    let filled = s.den;
    if (u < whole) filled = s.den;
    else filled = rest;

    if (s.showUnitLabel){
      drawUnitIndex(String(u+1), x + unitW/2, y - 18);
    }

    if (s.shape === "square" || s.shape === "rectangle"){
      drawSquareOrRectCanvas({
        x, y, w: unitW, h: unitH,
        den: s.den,
        filledParts: filled,
        fillColor: s.fillColor,
        strokeColor: s.strokeColor,
        showOutline: s.showOutline,
        mode: s.mode
      });
      if (gridWantedButNotPossible) warn = true;
    }

    if (s.shape === "circle"){
      const cx = x + unitW/2;
      const cy = y + unitH/2;
      const r = Math.min(unitW, unitH)/2;

      if (circleFastMode){
        drawCircleFast({
          cx, cy, r,
          frac: filled / s.den,
          fillColor: s.fillColor,
          strokeColor: s.strokeColor,
          showOutline: s.showOutline
        });
        warn = true;
      } else {
        drawCircleDetailed({
          cx, cy, r,
          den: s.den,
          filledParts: filled,
          fillColor: s.fillColor,
          strokeColor: s.strokeColor,
          showOutline: s.showOutline
        });
      }
    }
  }

  let msg = `Einheiten: ${units} (davon ${whole} ganz, Rest: ${rest}/${s.den})`;
  if (unitsClipped){ msg += ` — Anzeige begrenzt auf ${PERF.MAX_UNITS} Einheiten.`; warn = true; }
  if (s.denClipped){ msg += ` — Nenner begrenzt (${PERF.MAX_DEN}).`; warn = true; }
  if (circleFastMode){ msg += ` — Kreis-Schnellmodus aktiv.`; }
  if (gridWantedButNotPossible){
    msg += ` — Gitter nur bei Quadratzahlen (z.B. 4, 9, 16, 25, …); fallback: Streifen.`;
  }

  setStatus(msg, warn);
}

/** =========================
 *  SVG Export
 * ========================= */
function svgEsc(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function downloadText(filename, text, mime){
  const blob = new Blob([text], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function buildSVG(){
  const s = getInputs();
  const { whole, rest, units } = computeUnits(s.num, s.den);

  const clippedUnits = Math.min(units, PERF.MAX_UNITS);

  const margin = 20;
  const gap = 26;
  const top = 60;

  const svgW = 980;
  const { unitW, unitH } = computeLayout(s.shape, s.size);

  const maxPerRow = Math.max(1, Math.floor((svgW - 2*margin + gap) / (unitW + gap)));
  const rows = Math.ceil(clippedUnits / maxPerRow);
  const svgH = top + rows*(unitH + 50) + margin;

  const stroke = s.strokeColor;
  const fill = s.fillColor;

  const circleFastMode = (s.shape === "circle" && s.den > PERF.FAST_MODE_DEN);
  const gridPossible = Number.isInteger(Math.sqrt(s.den));
  const useGrid = (s.mode === "grid" && (s.shape === "square" || s.shape === "rectangle") && gridPossible);

  let parts = [];
  parts.push(`<?xml version="1.0" encoding="UTF-8"?>`);
  parts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}" viewBox="0 0 ${svgW} ${svgH}">`);
  parts.push(`<rect x="0" y="0" width="${svgW}" height="${svgH}" fill="#ffffff"/>`);

  if (s.showLabel){
    let label = `${s.originalNum}/${s.originalDen}`;
    if (s.simp.g > 1) label += ` (vereinfacht: ${s.simp.num}/${s.simp.den})`;
    if (s.denClipped) label += `  → Darstellung begrenzt (ca. ${s.num}/${s.den})`;
    parts.push(`<text x="${margin}" y="18" font-family="system-ui, Arial" font-size="16" fill="#111">${svgEsc(label)}</text>`);
  }

  for (let u=0; u<clippedUnits; u++){
    const row = Math.floor(u / maxPerRow);
    const col = u % maxPerRow;
    const x = margin + col*(unitW + gap);
    const y = top + row*(unitH + 50);

    let filled = s.den;
    if (u < whole) filled = s.den;
    else filled = rest;

    if (s.showUnitLabel){
      parts.push(`<text x="${x + unitW/2}" y="${y - 18}" text-anchor="middle" dominant-baseline="middle"
        font-family="system-ui, Arial" font-size="14" fill="#111">${u+1}</text>`);
    }

    if (s.shape === "square" || s.shape === "rectangle"){
      if (useGrid){
        const n = Math.sqrt(s.den);
        const rowsG = n, colsG = n;
        const cellW = unitW / colsG;
        const cellH = unitH / rowsG;

        let counter = 0;
        for (let r=0; r<rowsG; r++){
          for (let c=0; c<colsG; c++){
            const xx = x + c*cellW;
            const yy = y + r*cellH;

            if (counter < filled){
              parts.push(`<rect x="${xx}" y="${yy}" width="${cellW}" height="${cellH}" fill="${fill}"/>`);
            }
            if (s.showOutline){
              parts.push(`<rect x="${xx}" y="${yy}" width="${cellW}" height="${cellH}" fill="none" stroke="${stroke}" stroke-width="1.5"/>`);
            }
            counter++;
          }
        }
        // Außenrahmen
        parts.push(`<rect x="${x}" y="${y}" width="${unitW}" height="${unitH}" fill="none" stroke="${stroke}" stroke-width="3"/>`);
      } else {
        // Streifen
        const partH = unitH / s.den;

        // Füllung als einzelne Streifen (sauber)
        for (let i=0; i<s.den; i++){
          if (i < filled){
            parts.push(`<rect x="${x}" y="${y + i*partH}" width="${unitW}" height="${partH}" fill="${fill}"/>`);
          }
        }

        // Teil-Linien
        if (s.showOutline){
          for (let i=1; i<s.den; i++){
            const yy = y + i*partH;
            parts.push(`<line x1="${x}" y1="${yy}" x2="${x + unitW}" y2="${yy}" stroke="${stroke}" stroke-width="2"/>`);
          }
        }
        // Außenrahmen
        parts.push(`<rect x="${x}" y="${y}" width="${unitW}" height="${unitH}" fill="none" stroke="${stroke}" stroke-width="3"/>`);
      }
    }

    if (s.shape === "circle"){
      const cx = x + unitW/2;
      const cy = y + unitH/2;
      const r = Math.min(unitW, unitH)/2;

      // Außenkreis
      parts.push(`<circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="${stroke}" stroke-width="${s.showOutline ? 3 : 2}"/>`);

      if (circleFastMode){
        const frac = filled / s.den;
        if (frac > 0){
          const a0 = -Math.PI/2;
          const a1 = a0 + 2*Math.PI*frac;
          const x0 = cx + r*Math.cos(a0);
          const y0 = cy + r*Math.sin(a0);
          const x1 = cx + r*Math.cos(a1);
          const y1 = cy + r*Math.sin(a1);
          const largeArc = (a1 - a0) > Math.PI ? 1 : 0;
          const d = `M ${cx} ${cy} L ${x0} ${y0} A ${r} ${r} 0 ${largeArc} 1 ${x1} ${y1} Z`;
          parts.push(`<path d="${d}" fill="${fill}" stroke="none"/>`);
        }
        if (s.showOutline){
          const L = Math.max(2, Math.min(PERF.FAST_MODE_LINES, 60));
          for (let i=0;i<L;i++){
            const ang = (2*Math.PI/L)*i - Math.PI/2;
            const x2 = cx + r*Math.cos(ang);
            const y2 = cy + r*Math.sin(ang);
            parts.push(`<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="1.5"/>`);
          }
        }
      } else {
        // detailed Segmente
        for (let i=0;i<s.den;i++){
          const a0 = (2*Math.PI/s.den)*i - Math.PI/2;
          const a1 = (2*Math.PI/s.den)*(i+1) - Math.PI/2;
          const x0 = cx + r*Math.cos(a0);
          const y0 = cy + r*Math.sin(a0);
          const x1 = cx + r*Math.cos(a1);
          const y1 = cy + r*Math.sin(a1);
          const largeArc = (a1 - a0) > Math.PI ? 1 : 0;
          const d = `M ${cx} ${cy} L ${x0} ${y0} A ${r} ${r} 0 ${largeArc} 1 ${x1} ${y1} Z`;
          const segFill = (i < filled) ? fill : "none";
          const segStroke = s.showOutline ? stroke : "none";
          const segStrokeW = s.showOutline ? 2 : 0;
          parts.push(`<path d="${d}" fill="${segFill}" stroke="${segStroke}" stroke-width="${segStrokeW}"/>`);
        }
      }
    }
  }

  parts.push(`</svg>`);
  return parts.join("\n");
}

function downloadJPG(){
  // immer vorher neu zeichnen, damit Export aktuell ist
  drawCanvas();
  const a = document.createElement("a");
  a.download = "bruch.jpg";
  a.href = cnv.toDataURL("image/jpeg", 0.95);
  a.click();
}
function downloadSVG(){
  const svg = buildSVG();
  downloadText("bruch.svg", svg, "image/svg+xml;charset=utf-8");
}

/** =========================
 *  Events
 * ========================= */
document.getElementById("btnDraw").addEventListener("click", drawCanvas);
document.getElementById("btnJpg").addEventListener("click", downloadJPG);
document.getElementById("btnSvg").addEventListener("click", downloadSVG);

// Bei Änderungen neu zeichnen
["num","den","shape","mode","fillColor","strokeColor","showOutline","showLabel","showUnitLabel","size"]
  .forEach(id => document.getElementById(id).addEventListener("change", drawCanvas));

// initial
drawCanvas();
</script>
</body>
</html>

